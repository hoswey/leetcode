
// 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

// 示例 1:

// 输入: 4->2->1->3
// 输出: 1->2->3->4
// 示例 2:

// 输入: -1->5->3->4->0
// 输出: -1->0->3->4->5


/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func sortList(head *ListNode) *ListNode {

}
// 解题思路
// 本题要求在 O(n log n) 时间复杂度和常数级空间复杂度下排序

// 意味着不能用递归方法求解，那么只有迭代法
// 还有O(n log n)的时间复杂度表示只能用归并排序（Merge Sort）
// 接下来梳理一下算法思路：

// 首先要先确立链表的长度，然后通过for循环对链表元素进行倍速遍历（每次将上一步的两部分合为一部分）

// 定义first和second指针指向每一部分的头结点，每次事先保存每一部分的后继结点再将其断链送入Merge进行排序

// 将排序好的链表用pre指针连接起来，再将剩下的remain部分链表挂到尾部进入下一轮翻倍循环

// 等到最后一轮for循环结束，如有剩余元素就挂在已排序链表尾部，如果恰好等分排好整条链表，就返回dummy.next即可。

 